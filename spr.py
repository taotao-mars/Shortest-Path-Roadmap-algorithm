import sysimport numpy as npimport itertools as itimport heapqimport visualizefrom math import sqrtdef findReflexiveVertices(polygons):    vertices = []    for polygon in polygons:        for i in range(len(polygon)):            left = np.array(polygon[i - 1])            mid = np.array(polygon[i])            right = np.array(polygon[(i + 1) % len(polygon)])            det = np.linalg.det(np.array([left - mid, right - mid]))            if det > 0:                vertices.append(polygon[i])    return verticesdef computeSPRoadmap(polygons, reflexVertices):    vertexMap = dict()    revVertexMap = dict()    reflexMap = dict()    adjacencyListMap = dict()    for i in range(1, len(reflexVertices) + 1):        vertexMap[i] = reflexVertices[i - 1]        reflexMap[tuple(reflexVertices[i - 1])] = reflexVertices[i - 1]        revVertexMap[tuple(reflexVertices[i - 1])] = i    for polygon in polygons:        for i in range(len(polygon)):            left = reflexMap.get(tuple(polygon[i - 1]))            right = reflexMap.get(tuple(polygon[(i + 1) % len(polygon)]))            mid = reflexMap.get(tuple(polygon[i]))            if left != None and mid != None:                a, b = revVertexMap.get(tuple(mid)), revVertexMap.get(tuple(left))                adj = adjacencyListMap.get(a)                if adj == None:                    adjacencyListMap[a] = []                adjacencyListMap[a].append([b, calc_distance(mid, left)])            if right != None and mid != None:                # add right                a, b = revVertexMap.get(tuple(mid)), revVertexMap.get(tuple(right))                adj = adjacencyListMap.get(a)                if adj == None:                    adjacencyListMap[a] = []                adjacencyListMap[a].append([b, calc_distance(mid, right)])    poly_pairs = list(it.combinations(polygons, 2))    for poly1, poly2 in poly_pairs:        pointpairs = list(it.product(poly1, poly2))        otherpolies = polygons        for p1, p2 in pointpairs:            i1 = revVertexMap.get(tuple(p1))            i2 = revVertexMap.get(tuple(p2))            v = checkareVisible(p1, p2, otherpolies)            bi = checkareBitangent(p1, p2, poly1, poly2)            if v and bi and (i1 != None) and (i2 != None):                dis = calc_distance(p1, p2)                if (adjacencyListMap.get(i1) == None):                    adjacencyListMap[i1] = []                adjacencyListMap[i1].append([i2, dis])                if (adjacencyListMap.get(i2) == None):                    adjacencyListMap[i2] = []                adjacencyListMap[i2].append([i1, dis])    for poly in polygons:        p_pairs = list(it.combinations(poly, 2))        for p1, p2 in p_pairs:            v = checkareVisible(p1, p2, [poly])            bi = checkareBitangent(p1, p2, poly, poly)            if v and bi:                i1 = revVertexMap.get(tuple(p1))                i2 = revVertexMap.get(tuple(p2))                dis = calc_distance(p1, p2)                if (adjacencyListMap.get(i1) == None):                    adjacencyListMap[i1] = []                adjacencyListMap[i1].append([i2, dis])                if (adjacencyListMap.get(i2) == None):                    adjacencyListMap[i2] = []                adjacencyListMap[i2].append([i1, dis])    return vertexMap, adjacencyListMapdef uniformCostSearch(adjListMap, start, goal):    path = []    pathLength=0    gScore = dict()    cameFrom = dict()    openSet = dict()    openHeap = []    closedSet = dict()    gScore[start] = 0    t = (gScore[start], start)    heapq.heappush(openHeap, t)    openSet[start] = t    while (len(openHeap) > 0):        expNode = heapq.heappop(openHeap)        if expNode[1] == goal:            # trace through cameFrom to find the path            result_path = []            currNode = goal            while cameFrom.get(currNode) != None:                result_path.append(currNode)                currNode = cameFrom.get(currNode)            result_path.append(start)            result_path = result_path[::-1]            len_results = 0            for p1, p2 in zip(result_path[:len(result_path) - 1], result_path[1:]):                a = adjListMap.get(p1)                for edge in a:                    if edge[0] == p2:                        len_results += edge[1]                        break            return result_path, len_results        lip = adjListMap.get(expNode[1])        if lip == None:            lip = []        for neighbor in lip:            print neighbor            if closedSet.get(neighbor[0]) != None:                continue            t_gScore = gScore[expNode[1]] + neighbor[1]            if gScore.get(neighbor[0]) != None and gScore.get(neighbor[0]) <= t_gScore:                continue            cameFrom[neighbor[0]] = expNode[1]  # test            gScore[neighbor[0]] = t_gScore            temp = (gScore[neighbor[0]], neighbor[0])            if openSet.get(neighbor[0]) == None:                openSet[neighbor[0]] = temp                heapq.heappush(openHeap, temp)            else:                r = openSet[neighbor[0]]                r_i = openHeap.index(r)                openHeap[r_i] = temp                openSet[neighbor[0]] = temp                heapq.heapify(openHeap)    return [], 0def calc_distance(v1, v2):    x = (v1[0] - v2[0]) ** 2    y = (v1[1] - v2[1]) ** 2    return sqrt(x + y)def checkisReflexive(left, mid, right):    x = np.array(left)    y = np.array(mid)    z = np.array(right)    det = np.linalg.det(np.array([x - y, z - y]))    return det < 0def checkareBitangent(v1, v2, poly1, poly2):    mid1_index, mid2_index = poly1.index(v1), poly2.index(v2)    left1, left2 = poly1[mid1_index - 1], poly2[mid2_index - 1]    mid1, mid2 = poly1[mid1_index], poly2[mid2_index]    right1, right2 = poly1[(mid1_index + 1) % len(poly1)], poly2[(mid2_index + 1) % len(poly2)]    f = checkisReflexive    return not ((f(left1, mid1, mid2) != f(right1, mid1, mid2)) or (f(left2, mid2, mid1) != f(right2, mid2, mid1)))def ccw(A, B, C):    return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])def intersect(A, B, C, D):    return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)def lineSeg(a1, a2, b1, b2):    A1, A2, B1, B2 = np.array(a1), np.array(a2), np.array(b1), np.array(b2)    return intersect(A1, A2, B1, B2)def checkareVisible(v1, v2, otherPolygons):    for polygon in otherPolygons:        for p1, p2 in zip(polygon, polygon[1:] + [polygon[0]]):            if lineSeg(v1, v2, p2, p1) and p1 != v1 and v2 != p2 and p1 != v2 and p2 != v1:                return False    return Truedef specBitangent(s1, v1, poly1):    i1 = poly1.index(v1)    left = poly1[i1 - 1]    right = poly1[(i1 + 1) % len(poly1)]    a, b = checkisReflexive(s1, v1, left), checkisReflexive(s1, v1, right)    return a == bdef updateRoadmap(polygons, vertexMap, adjListMap, x1, y1, x2, y2):    updatedALMap= dict()    updatedALMap = adjListMap.copy()    startLabel = 0    goalLabel = -1    start = [x1, y1]    goal = [x2, y2]    polyMap = dict()    for polygon in polygons:        for i in vertexMap:            v = vertexMap.get(i)            if v in polygon:                polyMap[i] = polygon    if checkareVisible(start, goal, polygons):        if updatedALMap.get(startLabel) == None:            updatedALMap[startLabel] = []        if updatedALMap.get(goalLabel) == None:            updatedALMap[goalLabel] = []        updatedALMap[startLabel].append([goalLabel, calc_distance(start, goal)])        updatedALMap[goalLabel].append([startLabel, calc_distance(start, goal)])    for i in vertexMap:        v = vertexMap.get(i)        #f_poly = polyMap[i]        other_polygons = polygons        bi_start, vis_start = specBitangent(start, v, polyMap[i]), checkareVisible(start, v, other_polygons)        bi_goal, vis_goal = specBitangent(goal, v, polyMap[i]), checkareVisible(goal, v, other_polygons)        if bi_start and vis_start:            if updatedALMap.get(startLabel) == None:                updatedALMap[startLabel] = []            start_dist = calc_distance(start, v)            updatedALMap[startLabel].append([i, start_dist])            if updatedALMap.get(i) == None:                updatedALMap[i] = []            updatedALMap[i].append([startLabel, start_dist])    return startLabel, goalLabel, updatedALMapif __name__ == "__main__":    if (len(sys.argv) < 6):        print "Five arguments required: python spr.py [env-file] [x1] [y1] [x2] [y2]"        exit()    filename = sys.argv[1]    x1 = float(sys.argv[2])    y1 = float(sys.argv[3])    x2 = float(sys.argv[4])    y2 = float(sys.argv[5])    # Read data and parse polygons    lines = [line.rstrip('\n') for line in open(filename)]    polygons = []    for line in range(0, len(lines)):        xys = lines[line].split(';')        polygon = []        for p in range(0, len(xys)):            polygon.append(map(float, xys[p].split(',')))        polygons.append(polygon)    # Print out the data    print "Pologonal obstacles:"    for p in range(0, len(polygons)):        print str(polygons[p])    print ""    # Compute reflex vertices    reflexVertices = findReflexiveVertices(polygons)    print "Reflexive vertices:"    print str(reflexVertices)    print ""    # Compute the roadmap    vertexMap, adjListMap = computeSPRoadmap(polygons, reflexVertices)    print "Vertex map:"    print str(vertexMap)    print ""    print "Base roadmap:"    print str(adjListMap)    print ""    # Update roadmap    start, goal, updatedALMap = updateRoadmap(polygons, vertexMap, adjListMap, x1, y1, x2, y2)    print "Updated roadmap:"    print str(updatedALMap)    print ""    # Search for a solution    path, length = uniformCostSearch(updatedALMap, start, goal)    print "Final path:"    print str(path)    print "Final path length:" + str(length)    #extra    visualize.drawEverything(polygons, updatedALMap, vertexMap, path, [x1, y1], [x2, y2])